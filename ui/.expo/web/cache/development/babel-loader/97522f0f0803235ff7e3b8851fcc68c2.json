{"ast":null,"code":"import { call, take } from 'redux-saga/effects';\nimport { eventChannel } from 'redux-saga';\nimport SockJS from 'sockjs-client';\nimport * as Stomp from 'webstomp-client';\nimport AppConfig from \"../../config/app-config\";\nimport { processWebsocketMessage } from \"./websocket.sagas\";\nvar em;\nvar connectedPromise = null;\nvar connection = null;\nvar alreadyConnectedOnce = false;\nvar connected = false;\nvar socket = null;\nvar stompClient = null;\nvar wsSessionId = null;\nvar token = null;\nvar attempts = 0;\nvar chatSubscriber;\nfunction onConnect() {\n  setWsSessionId(socket);\n  connectedPromise.resolve('success');\n  connectedPromise = null;\n  connected = true;\n}\nfunction onError(error) {\n  console.warn(error);\n  var time = generateInterval(attempts);\n  alreadyConnectedOnce = false;\n  connected = false;\n  connectedPromise.reject('Error');\n  connectedPromise = null;\n  setTimeout(function () {\n    attempts++;\n    connect();\n  }, time);\n  console.warn(\"STOMP: Reconnecting in \" + Math.round(time / 1000) + \" seconds\");\n}\nfunction createConnection() {\n  return new Promise(function (resolve, reject) {\n    connectedPromise = {\n      resolve: resolve,\n      reject: reject\n    };\n  });\n}\nfunction connect() {\n  if (!alreadyConnectedOnce) {\n    if (connectedPromise === null) connection = createConnection();\n    var url = AppConfig.apiUrl + 'websocket/tracker';\n    if (token) {\n      url += '?access_token=' + token;\n    }\n    socket = new SockJS(url);\n    stompClient = Stomp.over(socket, {\n      protocols: ['v12.stomp']\n    });\n    console.log(\"Connecting to \" + url);\n    var headers = {};\n    stompClient.connect(headers, onConnect, onError);\n    alreadyConnectedOnce = true;\n  }\n}\nfunction disconnect() {\n  console.log('Disconnecting');\n  if (stompClient !== null && connected) {\n    stompClient.disconnect();\n    stompClient = null;\n  }\n  connected = false;\n  alreadyConnectedOnce = false;\n}\nfunction subscribeToChat() {\n  var _connection,\n    _this = this;\n  console.log('Subscribing to Chat');\n  (_connection = connection) == null ? void 0 : _connection.then(function () {\n    chatSubscriber = stompClient.subscribe('/topic/chat', onMessage.bind(_this, 'chat'));\n  });\n}\nfunction unsubscribeChat() {\n  if (chatSubscriber) {\n    chatSubscriber.unsubscribe();\n  }\n}\nfunction sendChat(message) {\n  if (stompClient !== null && stompClient.connected) {\n    stompClient.send('/topic/chat', JSON.stringify(message), {});\n  }\n}\nfunction onMessage(subscription, fullMessage) {\n  var msg = null;\n  try {\n    msg = JSON.parse(fullMessage.body);\n  } catch (e) {\n    console.warn(\"Error parsing : \" + fullMessage);\n    console.warn(e);\n  }\n  if (msg) {\n    return em({\n      subscription: subscription,\n      msg: msg\n    });\n  }\n}\nfunction getToken() {\n  return token;\n}\nfunction setToken(jwtToken) {\n  token = jwtToken;\n  if (connected) {\n    disconnect();\n    connect();\n  }\n}\nfunction getWsSessionId() {\n  return wsSessionId;\n}\nfunction setWsSessionId(socketObject) {\n  var splitUrl = socketObject._transport.url.split('/');\n  wsSessionId = splitUrl[5];\n  console.log(\"Set WS Session ID to \" + wsSessionId);\n}\nfunction getConnectedPromise() {\n  return connection;\n}\nfunction generateInterval(k) {\n  var maxInterval = (Math.pow(2, k) - 1) * 1000;\n  if (maxInterval > 30 * 1000) {\n    maxInterval = 30 * 1000;\n  }\n  return Math.random() * maxInterval;\n}\nexport default {\n  onConnect: onConnect,\n  onError: onError,\n  subscribeToChat: subscribeToChat,\n  unsubscribeChat: unsubscribeChat,\n  connect: connect,\n  disconnect: disconnect,\n  createConnection: createConnection,\n  sendChat: sendChat,\n  getToken: getToken,\n  setToken: setToken,\n  getWsSessionId: getWsSessionId,\n  getConnectedPromise: getConnectedPromise,\n  initWebsocket: initWebsocket,\n  websocketSagas: websocketSagas\n};\nfunction initWebsocket() {\n  return eventChannel(function (emitter) {\n    em = emitter;\n    return function () {\n      console.log('Socket off');\n    };\n  });\n}\nfunction* websocketSagas() {\n  var channel = yield call(initWebsocket);\n  while (true) {\n    var action = yield take(channel);\n    yield call(processWebsocketMessage, action);\n  }\n}","map":{"version":3,"names":["call","take","eventChannel","SockJS","Stomp","AppConfig","processWebsocketMessage","em","connectedPromise","connection","alreadyConnectedOnce","connected","socket","stompClient","wsSessionId","token","attempts","chatSubscriber","onConnect","setWsSessionId","resolve","onError","error","console","warn","time","generateInterval","reject","setTimeout","connect","Math","round","createConnection","Promise","url","apiUrl","over","protocols","log","headers","disconnect","subscribeToChat","_connection","_this","then","subscribe","onMessage","bind","unsubscribeChat","unsubscribe","sendChat","message","send","JSON","stringify","subscription","fullMessage","msg","parse","body","e","getToken","setToken","jwtToken","getWsSessionId","socketObject","splitUrl","_transport","split","getConnectedPromise","k","maxInterval","pow","random","initWebsocket","websocketSagas","emitter","channel","action"],"sources":["/Users/albertodelazzari/repositories/ambulanza_veloce/ui/app/shared/websockets/websocket.service.js"],"sourcesContent":["import { call, take } from 'redux-saga/effects';\nimport { eventChannel } from 'redux-saga';\nimport SockJS from 'sockjs-client';\nimport * as Stomp from 'webstomp-client';\n\nimport AppConfig from '../../config/app-config';\nimport { processWebsocketMessage } from './websocket.sagas';\n\nlet em;\nlet connectedPromise = null;\nlet connection = null;\nlet alreadyConnectedOnce = false;\nlet connected = false;\nlet socket = null;\nlet stompClient = null;\nlet wsSessionId = null;\nlet token = null;\nlet attempts = 0;\n\nlet chatSubscriber;\n\nfunction onConnect() {\n  setWsSessionId(socket);\n  connectedPromise.resolve('success');\n  connectedPromise = null;\n  connected = true;\n}\n\nfunction onError(error) {\n  console.warn(error);\n  const time = generateInterval(attempts);\n  alreadyConnectedOnce = false;\n  connected = false;\n  connectedPromise.reject('Error');\n  connectedPromise = null;\n  setTimeout(function () {\n    attempts++;\n    connect();\n  }, time);\n  console.warn(`STOMP: Reconnecting in ${Math.round(time / 1000)} seconds`);\n}\n\nfunction createConnection() {\n  return new Promise((resolve, reject) => {\n    connectedPromise = { resolve, reject };\n  });\n}\n// methods for connecting/disconnecting\nfunction connect() {\n  if (!alreadyConnectedOnce) {\n    if (connectedPromise === null) connection = createConnection();\n    var url = AppConfig.apiUrl + 'websocket/tracker';\n    if (token) {\n      url += '?access_token=' + token;\n    }\n    socket = new SockJS(url);\n    stompClient = Stomp.over(socket, { protocols: ['v12.stomp'] });\n    // stompClient.debug = null\n    console.log(`Connecting to ${url}`);\n    var headers = {};\n    stompClient.connect(headers, onConnect, onError);\n    alreadyConnectedOnce = true;\n  }\n}\n\nfunction disconnect() {\n  console.log('Disconnecting');\n  if (stompClient !== null && connected) {\n    stompClient.disconnect();\n    stompClient = null;\n  }\n  connected = false;\n  alreadyConnectedOnce = false;\n}\n\n// methods for subscribing\nfunction subscribeToChat() {\n  console.log('Subscribing to Chat');\n  connection?.then(() => {\n    chatSubscriber = stompClient.subscribe('/topic/chat', onMessage.bind(this, 'chat'));\n  });\n}\n\n// methods for unsubscribing\nfunction unsubscribeChat() {\n  if (chatSubscriber) {\n    chatSubscriber.unsubscribe();\n  }\n}\n\n// method for sending\nfunction sendChat(message) {\n  if (stompClient !== null && stompClient.connected) {\n    stompClient.send('/topic/chat', JSON.stringify(message), {});\n  }\n}\n\n// when the message is received, send it to the WebsocketSaga\nfunction onMessage(subscription, fullMessage) {\n  let msg = null;\n  try {\n    msg = JSON.parse(fullMessage.body);\n  } catch (e) {\n    console.warn(`Error parsing : ${fullMessage}`);\n    console.warn(e);\n  }\n  if (msg) {\n    return em({ subscription, msg });\n  }\n}\n\n// getters and setters\nfunction getToken() {\n  return token;\n}\n\nfunction setToken(jwtToken) {\n  token = jwtToken;\n  if (connected) {\n    disconnect();\n    connect();\n  }\n}\n\nfunction getWsSessionId() {\n  return wsSessionId;\n}\n\nfunction setWsSessionId(socketObject) {\n  const splitUrl = socketObject._transport.url.split('/');\n  wsSessionId = splitUrl[5];\n  console.log(`Set WS Session ID to ${wsSessionId}`);\n}\n\nfunction getConnectedPromise() {\n  return connection;\n}\n\n// exponential backoff for reconnections\nfunction generateInterval(k) {\n  let maxInterval = (Math.pow(2, k) - 1) * 1000;\n\n  if (maxInterval > 30 * 1000) {\n    // If the generated interval is more than 30 seconds, truncate it down to 30 seconds.\n    maxInterval = 30 * 1000;\n  }\n  // generate the interval to a random number between 0 and the maxInterval determined from above\n  return Math.random() * maxInterval;\n}\n\nexport default {\n  onConnect,\n  onError,\n  subscribeToChat,\n  unsubscribeChat,\n  connect,\n  disconnect,\n  createConnection,\n  sendChat,\n  getToken,\n  setToken,\n  getWsSessionId,\n  getConnectedPromise,\n  initWebsocket,\n  websocketSagas,\n};\n\n// connects to the websocket and sends events\nfunction initWebsocket() {\n  return eventChannel(emitter => {\n    em = emitter;\n    // unsubscribe function\n    return () => {\n      console.log('Socket off');\n    };\n  });\n}\n\nfunction* websocketSagas() {\n  const channel = yield call(initWebsocket);\n  while (true) {\n    const action = yield take(channel);\n    yield call(processWebsocketMessage, action);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}